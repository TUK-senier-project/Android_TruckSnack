Index: app/src/main/java/com/example/icontest2/customer_register/SignUpActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.icontest2.customer_register\r\n\r\nimport android.content.Intent\r\nimport android.content.pm.PackageManager\r\nimport android.graphics.Color\r\nimport android.location.Geocoder\r\nimport android.os.Bundle\r\nimport android.text.*\r\nimport android.text.style.ForegroundColorSpan\r\nimport android.util.Log\r\nimport android.widget.Button\r\nimport android.widget.EditText\r\nimport android.widget.Toast\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.core.app.ActivityCompat\r\nimport androidx.core.content.ContextCompat\r\nimport com.example.icontest2.MainActivity\r\nimport com.example.icontest2.R\r\nimport com.example.icontest2.customer_login.CustomerLoginActivity\r\nimport com.example.icontest2.databinding.ActivitySignUpBinding\r\nimport com.google.android.gms.location.LocationServices\r\nimport com.google.android.gms.maps.CameraUpdateFactory\r\nimport com.google.android.gms.maps.GoogleMap\r\nimport com.google.android.gms.maps.OnMapReadyCallback\r\nimport com.google.android.gms.maps.SupportMapFragment\r\nimport com.google.android.gms.maps.model.LatLng\r\nimport com.google.android.gms.maps.model.MarkerOptions\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.GlobalScope\r\nimport kotlinx.coroutines.launch\r\nimport retrofit2.Retrofit\r\nimport retrofit2.Response\r\nimport retrofit2.converter.gson.GsonConverterFactory\r\nimport java.util.*\r\n\r\nclass SignUpActivity : AppCompatActivity(){\r\n    private lateinit var binding: ActivitySignUpBinding\r\n    private lateinit var mMap: GoogleMap\r\n    private lateinit var buttonLocation: Button\r\n    private val REQUEST_LOCATION_PERMISSION = 1\r\n    private var TAG = \"SignUpActivity\"\r\n\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?){\r\n        super.onCreate(savedInstanceState)\r\n        binding = ActivitySignUpBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n        \r\n        // 아이디, 비밀번호, 비밀번호 확인, 이름, 휴대폰번호의 editText id\r\n        val signUpBtn = binding.signUpBtn\r\n        val signUptextIdLengthChecker = binding.mainTextInputLayoutID\r\n        val signUptextPwLengthChecker = binding.mainTextInputLayoutPW\r\n        val signUptextPwLengthChecker2 = binding.mainTextInputLayoutPW2 // 2번째 pw\r\n        val lengthCheck = binding.mainTextInputLayoutCreateName\r\n        val signUPEdit_ID = binding.EditID // 아이디 만들기\r\n        val signUPEdit_PW = binding.EditPW // 비밀번호 만들기\r\n        val signUpCreate_name = binding.createName // 이름 만들기\r\n        val signUpCreate_phone_number = binding.phoneNumberCreate // 폰번호 숫자만 11자제한\r\n        val editText = binding.editText // 위치 조회값\r\n        val EditPW2 = binding.EditPW2\r\n        setEditTextInput(signUpCreate_phone_number, 11)\r\n        val signUpCheckBtn = binding.signUpBtn\r\n        val customerIdCheck = binding.customerRegisterIdCheckBtn\r\n\r\n        buttonLocation = findViewById(R.id.button_location) // 사용자 위치 조회 및 입력\r\n        buttonLocation.setOnClickListener {\r\n            requestLocationPermission()\r\n            showUserLocation()\r\n        }\r\n        val mapFragment = supportFragmentManager.findFragmentById(R.id.map) as SupportMapFragment\r\n        mapFragment.getMapAsync(this)\r\n\r\n        val buttonShowLocation = findViewById<Button>(R.id.button_location)\r\n        buttonShowLocation.setOnClickListener {\r\n            if (ContextCompat.checkSelfPermission(this,\r\n                    android.Manifest.permission.ACCESS_FINE_LOCATION)\r\n                == PackageManager.PERMISSION_GRANTED) {\r\n                // 위치 권한이 허용된 경우\r\n                showUserLocation()\r\n            } else {\r\n                // 위치 권한이 허용되지 않은 경우\r\n                ActivityCompat.requestPermissions(this,\r\n                    arrayOf(android.Manifest.permission.ACCESS_FINE_LOCATION),\r\n                    REQUEST_LOCATION_PERMISSION)\r\n            }\r\n        }\r\n\r\n        // 아이디, 패스워드 초과 경고 메세지\r\n        fun textLengthChecker(): Boolean {\r\n            var isValid = true\r\n            signUptextIdLengthChecker.isCounterEnabled = true\r\n            signUptextPwLengthChecker.isCounterEnabled = true\r\n            lengthCheck.isCounterEnabled = true\r\n            signUptextIdLengthChecker.counterMaxLength = 15 // ID 최대 길이\r\n            signUptextPwLengthChecker.counterMaxLength = 20 // PW 최대 길이\r\n            lengthCheck.counterMaxLength = 10\r\n            signUptextIdLengthChecker.isErrorEnabled = true\r\n            signUptextPwLengthChecker.isErrorEnabled = true\r\n            lengthCheck.isErrorEnabled = true\r\n\r\n            signUPEdit_ID.addTextChangedListener(object : TextWatcher {\r\n                override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {}\r\n                override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {}\r\n                override fun afterTextChanged(p0: Editable?) {\r\n                    if (signUPEdit_ID.text.contains(\" \")) {\r\n                        signUptextIdLengthChecker.error = \"공백이 포함될 수 없습니다.\"\r\n                        isValid = false\r\n                    } else {\r\n                        if (signUPEdit_ID.length() > 15) {\r\n                            signUptextIdLengthChecker.error = \"ID의 글자 수를 초과하였습니다.\"\r\n                            isValid = false\r\n                        } else if (signUPEdit_ID.length() < 5) {\r\n                            signUptextIdLengthChecker.error = \"ID는 최소 5자 이상입니다.\"\r\n                            isValid = false\r\n                        } else {\r\n                            signUptextIdLengthChecker.error = null\r\n                        }\r\n                    }\r\n                }\r\n            })\r\n            signUPEdit_PW.addTextChangedListener(object : TextWatcher {\r\n                override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                }\r\n                override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                }\r\n                override fun afterTextChanged(p0: Editable?) {\r\n                    val pw = p0.toString()\r\n                    if (pw.contains(\" \")) {\r\n                        signUptextPwLengthChecker.error = \"공백을 포함할 수 없습니다.\"\r\n                        isValid = false\r\n                    } else if (pw.length > 20) {\r\n                        signUptextPwLengthChecker.error = \"PW의 글자 수를 초과하였습니다.\"\r\n                        isValid = false\r\n                    } else if (pw.length < 8) {\r\n                        signUptextPwLengthChecker.error = \"PW는 최소 8자 이상입니다.\"\r\n                        isValid = false\r\n                    } else {\r\n                        signUptextPwLengthChecker.error = null\r\n                    }\r\n                }\r\n            })\r\n            signUpCreate_name.addTextChangedListener(object : TextWatcher {\r\n                override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                }\r\n                override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                    if (signUpCreate_name.length() > 10) {\r\n                        lengthCheck.error = \"이름의 글자 수를 초과 하였습니다.\"\r\n                        isValid = false\r\n                    } else {\r\n                        lengthCheck.error = null\r\n                    }\r\n                }\r\n                override fun afterTextChanged(p0: Editable?) {\r\n                }\r\n            })\r\n            return isValid\r\n        }\r\n        fun textLengthChecker2(): Boolean {\r\n            signUptextPwLengthChecker2.isCounterEnabled = true\r\n            signUptextPwLengthChecker2.counterMaxLength = 20\r\n            signUptextPwLengthChecker2.isErrorEnabled = true\r\n            var isValid = true\r\n            EditPW2.addTextChangedListener(object : TextWatcher {\r\n                override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {}\r\n                override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {}\r\n                override fun afterTextChanged(p0: Editable?) {\r\n                    val pw = p0.toString()\r\n                    if (pw.contains(\" \")) {\r\n                        signUptextPwLengthChecker2.error = \"공백을 포함할 수 없습니다.\"\r\n                        isValid = false\r\n                    } else if (pw.length > 20) {\r\n                        signUptextPwLengthChecker2.error = \"PW의 글자 수를 초과하였습니다.\"\r\n                        isValid = false\r\n                    } else if (pw.length < 8) {\r\n                        signUptextPwLengthChecker2.error = \"PW는 최소 8자 이상입니다.\"\r\n                        isValid = false\r\n                    } else {\r\n                        signUptextPwLengthChecker2.error = null\r\n                        isValid = true\r\n                    }\r\n                }\r\n            })\r\n            return isValid\r\n        }\r\n        notKorean(signUPEdit_ID) // id 한글 예외처리\r\n        notKorean(signUPEdit_PW) // pw 한글 예외처리\r\n        notKorean(EditPW2) // 2번째 pw 한글 예외처리\r\n        onlyKorean(signUpCreate_name) // 이름 입력시 한글만\r\n        checkwhite(signUpCreate_name) // 이름 입력시 공백 확인\r\n        textLengthChecker() // 문자길이 체크\r\n        textLengthChecker2() // 2번째 pw\r\n        checkKoreanNumber(editText) // 한글 + 숫자 확인 함수(영어 입력 X)\r\n        onlyEnglishAndNumber(signUPEdit_PW) // 영어와 숫자만 입력되게\r\n        onlyEnglishAndNumber(EditPW2) // 2번째 pw 영어와 숫자만 입력되게\r\n\r\n\r\n        // 아이디 중복체크 기능\r\n        customerIdCheck.setOnClickListener {\r\n            Log.d(TAG, \"접속 성공\")\r\n            val customerId = signUPEdit_ID.text.toString()\r\n            // customerId가 빈 문자열인 경우\r\n            if (customerId.isEmpty()) {\r\n                Toast.makeText(this, \"아이디를 입력해주세요.\", Toast.LENGTH_SHORT).show()\r\n                return@setOnClickListener\r\n            }\r\n            val customerCheckIdDTO = CustomerCheckIdDTO(customerId)\r\n            val retrofit = Retrofit.Builder()\r\n                .baseUrl(\"http://13.209.18.214:8080\")\r\n                .addConverterFactory(GsonConverterFactory.create())\r\n                .build()\r\n            val customerRegisterAPI = retrofit.create(CustomerRegisterAPI::class.java)\r\n            GlobalScope.launch(Dispatchers.IO) {\r\n                try {Log.d(TAG, \"접속 성공2\")\r\n                    val response = customerRegisterAPI.registerCustomerIdCheck(customerCheckIdDTO)\r\n                    // 서버로부터 받은 응답에 따라 Toast 메시지를 띄워줌\r\n                    if (response.isSuccessful) {\r\n                        Log.d(TAG, \"사용 가능 아이디\")\r\n                        runOnUiThread {\r\n                            Toast.makeText(this@SignUpActivity, \"사용 가능한 아이디입니다.\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n                    } else {\r\n                        Log.d(TAG, \"사용 불가능 아이디 \")\r\n                        runOnUiThread {\r\n                            Toast.makeText(this@SignUpActivity, \"중복된 아이디입니다.\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n                    }\r\n                } catch (e: Exception) {\r\n                    Log.d(TAG, \"예외 \")\r\n                    e.printStackTrace()\r\n                    runOnUiThread {\r\n                        Toast.makeText(this@SignUpActivity, \"서버와의 통신에 실패했습니다.\", Toast.LENGTH_SHORT).show()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // 회원 가입 전 에러메세지 유무 확인\r\n        signUpCheckBtn.setOnClickListener {\r\n            var hasError = false\r\n            val editTextList = listOf(binding.mainTextInputLayoutID.editText, binding.mainTextInputLayoutPW.editText,\r\n                binding.mainTextInputLayoutPW2.editText, binding.mainTextInputLayoutCreateName.editText,\r\n                binding.EditID, binding.EditPW, binding.createName, binding.phoneNumberCreate)\r\n            for (editText in editTextList) {\r\n                if (editText != null) {\r\n                    if (editText.error?.isNotBlank() == true) { // 에러 메시지가 비어있지 않은 경우\r\n                        hasError = true\r\n                        break\r\n                    }\r\n                }\r\n            }\r\n            if (hasError) {\r\n                Toast.makeText(this, \"입력값을 수정해주세요.\", Toast.LENGTH_SHORT).show()\r\n            }\r\n            //else {\r\n                //Toast.makeText(this, \"회원가입 성공!\", Toast.LENGTH_SHORT).show()\r\n            //}\r\n        }\r\n        Log.d(TAG, \"버튼 클릭 전 로그 체크!!}\")\r\n\r\n        signUpBtn.setOnClickListener {\r\n            Log.d(TAG, \"버튼 클릭 후 로그 체크!!}\")\r\n            val id = signUPEdit_ID.text.toString()\r\n            val password = signUPEdit_PW.text.toString()\r\n            val name = signUpCreate_name.text.toString()\r\n            val phoneNumber = signUpCreate_phone_number.text.toString()\r\n            val location = editText.text.toString()\r\n            val customer = CustomerRegisterDTO(id, name, password, phoneNumber, location)\r\n            Log.d(TAG, \"$customer\")\r\n            Log.d(TAG, \"${id::class.java}\")\r\n            Log.d(TAG, \"${password::class.java}\")\r\n            Log.d(TAG, \"${name::class.java}\")\r\n            Log.d(TAG, \"${phoneNumber::class.java}\")\r\n            Log.d(TAG, \"${location::class.java}\")\r\n            val retrofit = Retrofit.Builder() // 서버통신\r\n                .baseUrl(\"http://13.209.18.214:8080\")\r\n                .addConverterFactory(GsonConverterFactory.create())\r\n                .build()\r\n            // API 서비스 인터페이스 구현체 생성\r\n            val customerAPI = retrofit.create(CustomerRegisterAPI::class.java)\r\n            GlobalScope.launch(Dispatchers.IO) {\r\n                try {\r\n                    val response = customerAPI.registerCustomer(customer)\r\n                    Log.d(TAG, \"서버 통신 전 로그 체크!!}\")\r\n                    if (response.isSuccessful) {\r\n                        Log.d(TAG, \"서버 성공 로그 체크!!}\")\r\n                        Log.d(TAG, \"${response.body()}\")\r\n                        Log.d(TAG, \"$response\")\r\n                        runOnUiThread {\r\n                            val intent = Intent(this@SignUpActivity, MainActivity::class.java)\r\n                            startActivity(intent)\r\n                            Toast.makeText(this@SignUpActivity, \"회원가입이 완료되었습니다.\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n\r\n                        // 성공 처리\r\n                    } else {\r\n                        // 실패 처리\r\n                        Log.d(TAG, \"서버 실패 로그 체크!!}\")\r\n                        Log.d(TAG, \"${response.errorBody()}\")\r\n                        Log.d(TAG, \"$response\")\r\n                        runOnUiThread {\r\n                            Toast.makeText(this@SignUpActivity, \"오류가 없는지 확인해주세요\", Toast.LENGTH_SHORT).show()\r\n                        }\r\n                    }\r\n                } catch (e: Exception) {\r\n                    // 예외 처리\r\n                    Log.d(TAG, \"서버 예외 로그 체크!!}\")\r\n                    Log.d(TAG, \"$e\")\r\n                }\r\n            }\r\n        }\r\n    } // 온크리에이트 종료\r\n    // 영어와 숫자가 입력될 수 있게 하는 함수\r\n    fun onlyEnglishAndNumber(editText: EditText): Boolean {\r\n        Log.d(TAG, \" - onlyEnglishAndNumber\")\r\n        editText.addTextChangedListener(object : TextWatcher {\r\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}\r\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\r\n            override fun afterTextChanged(s: Editable?) {\r\n                val text = s.toString()\r\n                if (!text.matches(Regex(\"[a-zA-Z0-9]+\"))) {\r\n                    val errorMsg = \"반드시 영어와 숫자를 섞어서 입력해주세요.\"\r\n                    val spannableString = SpannableStringBuilder(errorMsg)\r\n                    spannableString.setSpan(\r\n                        ForegroundColorSpan(Color.RED),\r\n                        0,\r\n                        errorMsg.length,\r\n                        Spannable.SPAN_EXCLUSIVE_EXCLUSIVE\r\n                    )\r\n                    editText.error = spannableString\r\n                } else {\r\n                    editText.error = null\r\n                }\r\n            }\r\n        })\r\n        return true\r\n    }\r\n    // 한글예외처리 함수\r\n    fun notKorean(editText: EditText): Boolean {\r\n        Log.d(TAG, \" - checkNotKorean\")\r\n        editText.addTextChangedListener(object : TextWatcher {\r\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}\r\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\r\n            override fun afterTextChanged(s: Editable?) {\r\n                val text = s.toString()\r\n                if (text.matches(Regex(\"[^a-zA-Z0-9 ]+\")) || text.matches(Regex(\".*[ㄱ-ㅎㅏ-ㅣ가-힣]+.*\"))) {\r\n                    editText.error = \"영어와 숫자만 입력 가능합니다.\"\r\n                } else {\r\n                    editText.error = null\r\n                }\r\n            }\r\n        })\r\n        return true\r\n    }\r\n\r\n    // 한글 + 숫자 확인 함수(영어 입력 X)\r\n    fun checkKoreanNumber(editText: EditText): Boolean {\r\n        Log.d(TAG, \" - checkKorean\")\r\n        val text = editText.text.toString()\r\n        if (text.contains(Regex(\"[^ㄱ-ㅎㅏ-ㅣ가-힣0-9 ]\"))) {\r\n            editText.error = \"한글과 숫자만 입력 가능합니다.\"\r\n            return false\r\n        } else {\r\n            editText.error = null\r\n            return editText.error.isNullOrEmpty()\r\n        }\r\n    }\r\n\r\n    // 한글만 입력함수\r\n    fun onlyKorean(editText: EditText) {\r\n        Log.d(TAG, \" - checkOnlyKorean\")\r\n        editText.addTextChangedListener(object : TextWatcher {\r\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}\r\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\r\n            override fun afterTextChanged(s: Editable?) {\r\n                val text = s.toString()\r\n                if (!text.matches(Regex(\"[ㄱ-ㅎㅏ-ㅣ가-힣ㆍ ]*\"))) {\r\n                    val lastCharIndex = s!!.length - 1\r\n                    val lastChar = text[lastCharIndex].toString()\r\n                    editText.setText(text.replace(lastChar, \"\"))\r\n                    editText.setSelection(s.length - 1)\r\n                    editText.error = \"한글만 입력 가능합니다.\"\r\n                }\r\n            }\r\n        })\r\n    }\r\n    // 공백체크함수\r\n    fun checkwhite(editText: EditText): Boolean {\r\n        editText.addTextChangedListener(object : TextWatcher {\r\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}\r\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\r\n            override fun afterTextChanged(s: Editable?) {\r\n                val text = s.toString()\r\n                Log.d(TAG, \"${text} - checkWhiteSpace\")\r\n                if (text.contains(\" \")) {\r\n                    Log.d(TAG, \"${text} - 공백있음\")\r\n                    editText.error = \"공백이 포함되어 있습니다.\"\r\n                } else {\r\n                    editText.error = null\r\n                }\r\n            }\r\n        })\r\n        return true\r\n    }\r\n\r\n    // 폰번호 입력시 11자제한, 숫자만 입력\r\n    fun setEditTextInput(editText: EditText, maxLength: Int): Boolean {\r\n        val inputFilter = arrayOf<InputFilter>(InputFilter { source, _, _, _, _, _ ->\r\n            if (source.toString().matches(Regex(\"[0-9]+\"))) {\r\n                null // 숫자일 경우, null 리턴\r\n            } else {\r\n                \"\" // 숫자가 아닐 경우, 빈 문자열(\"\") 리턴\r\n            }\r\n        })\r\n        editText.filters = inputFilter\r\n        editText.addTextChangedListener(object : TextWatcher {\r\n            override fun afterTextChanged(s: Editable?) {\r\n                val input = s.toString()\r\n                if (input.length > maxLength) {\r\n                    editText.error = \"입력할 수 있는 숫자는 ${maxLength}자리 이하입니다.\"\r\n                } else if (input.length < 11) {\r\n                    editText.error = \"11자리까지 숫자만 입력해주세요.\"\r\n                } else {\r\n                    editText.error = null // 에러 없음\r\n                }\r\n                val text = s.toString()\r\n                Log.d(TAG, \"${text} - checkWhiteSpace\")\r\n                // 결과 출력\r\n                if (text.contains(\" \")) {\r\n                    Log.d(TAG, \"${text} - 공백있음\")\r\n                    editText.error = \"공백이 포함되어 있습니다.\"\r\n                }\r\n            }\r\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}\r\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\r\n        })\r\n        return true\r\n    }\r\n\r\n\r\n    // 사용자 위치 조회, 위치 입력\r\n    private fun showUserLocation() {\r\n        val editText = findViewById<EditText>(R.id.editText)\r\n        if (ContextCompat.checkSelfPermission(this,\r\n                android.Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\r\n            mMap.isMyLocationEnabled = true\r\n\r\n            // 사용자 위치 가져오기\r\n            val fusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this)\r\n            fusedLocationProviderClient.lastLocation.addOnSuccessListener { location ->\r\n                if (location != null) {\r\n                    val geocoder = Geocoder(this, Locale.KOREAN)\r\n                    val addresses = geocoder.getFromLocation(location.latitude, location.longitude, 1)\r\n                    if (addresses != null) {\r\n                        if (addresses.isNotEmpty()) {\r\n                            val address = addresses[0]\r\n                            val addressStr = address.getAddressLine(0)\r\n                            editText.setText(addressStr)\r\n                        }\r\n                    }\r\n\r\n\r\n                    val latLng = LatLng(location.latitude, location.longitude)\r\n                    mMap.addMarker(MarkerOptions().position(latLng).title(\"User Location\"))\r\n                    mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng, 15f))\r\n                }\r\n            }\r\n        }\r\n    }\r\n    override fun onMapReady(googleMap: GoogleMap) {\r\n        mMap = googleMap\r\n        mMap.uiSettings.isZoomControlsEnabled = true\r\n    }\r\n    override fun onRequestPermissionsResult(\r\n        requestCode: Int,\r\n        permissions: Array<out String>,\r\n        grantResults: IntArray\r\n    ) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\r\n        if (requestCode == REQUEST_LOCATION_PERMISSION) {\r\n            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                showUserLocation()\r\n            }\r\n        }\r\n    }\r\n    private fun requestLocationPermission() {\r\n        if (ContextCompat.checkSelfPermission(\r\n                this,\r\n                android.Manifest.permission.ACCESS_FINE_LOCATION\r\n            ) == PackageManager.PERMISSION_GRANTED\r\n        ) {\r\n            showUserLocation()\r\n        } else {\r\n            ActivityCompat.requestPermissions(\r\n                this,\r\n                arrayOf(android.Manifest.permission.ACCESS_FINE_LOCATION),\r\n                REQUEST_LOCATION_PERMISSION\r\n            )\r\n        }\r\n        \r\n    }\r\n\r\n\r\n}\r\n
===================================================================
diff --git a/app/src/main/java/com/example/icontest2/customer_register/SignUpActivity.kt b/app/src/main/java/com/example/icontest2/customer_register/SignUpActivity.kt
--- a/app/src/main/java/com/example/icontest2/customer_register/SignUpActivity.kt	
+++ b/app/src/main/java/com/example/icontest2/customer_register/SignUpActivity.kt	
@@ -33,14 +33,13 @@
 import retrofit2.converter.gson.GsonConverterFactory
 import java.util.*
 
-class SignUpActivity : AppCompatActivity(){
+class SignUpActivity : AppCompatActivity(), OnMapReadyCallback{
     private lateinit var binding: ActivitySignUpBinding
     private lateinit var mMap: GoogleMap
     private lateinit var buttonLocation: Button
     private val REQUEST_LOCATION_PERMISSION = 1
     private var TAG = "SignUpActivity"
 
-
     override fun onCreate(savedInstanceState: Bundle?){
         super.onCreate(savedInstanceState)
         binding = ActivitySignUpBinding.inflate(layoutInflater)
