Index: app/src/main/java/com/example/icontest2/SignUpActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.icontest2\r\n\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport android.os.Bundle\r\nimport android.text.Editable\r\nimport android.text.InputFilter\r\nimport android.text.TextWatcher\r\nimport android.util.Log\r\nimport android.widget.EditText\r\nimport com.example.icontest2.databinding.ActivitySignUpBinding\r\nimport java.util.regex.Pattern\r\nimport android.Manifest\r\nimport android.content.Intent\r\nimport android.content.pm.PackageManager\r\nimport android.location.Geocoder\r\nimport android.widget.Button\r\nimport androidx.core.app.ActivityCompat\r\nimport androidx.core.content.ContextCompat\r\nimport com.google.android.gms.location.LocationServices\r\nimport com.google.android.gms.maps.CameraUpdateFactory\r\nimport com.google.android.gms.maps.GoogleMap\r\nimport com.google.android.gms.maps.OnMapReadyCallback\r\nimport com.google.android.gms.maps.SupportMapFragment\r\nimport com.google.android.gms.maps.model.LatLng\r\nimport com.google.android.gms.maps.model.MarkerOptions\r\nimport java.util.*\r\n\r\n\r\nclass SignUpActivity : AppCompatActivity(), OnMapReadyCallback {\r\n    private lateinit var binding: ActivitySignUpBinding\r\n    private lateinit var mMap: GoogleMap\r\n    private lateinit var buttonLocation: Button\r\n    private val REQUEST_LOCATION_PERMISSION = 1\r\n    private var TAG = \"SignUpActivity\"\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?){\r\n        super.onCreate(savedInstanceState)\r\n        binding = ActivitySignUpBinding.inflate(layoutInflater)\r\n        setContentView(binding.root)\r\n\r\n        // 아이디, 비밀번호, 비밀번호 확인, 이름, 휴대폰번호의 editText id\r\n        val signUpBtn = binding.signUpBtn\r\n        val signUptextIdLengthChecker = binding.mainTextInputLayoutID\r\n        val signUptextPwLengthChecker = binding.mainTextInputLayoutPW\r\n        val lengthCheck = binding.mainTextInputLayoutCreateName\r\n        val signUPEdit_ID = binding.EditID // 아이디 만들기\r\n        val signUPEdit_PW = binding.EditPW // 비밀번호 만들기\r\n        val signUpCreate_name = binding.createName // 이름 만들기\r\n        val signUpCreate_phone_number = binding.phoneNumberCreate // 폰번호 숫자만 11자제한\r\n        setEditTextInput(signUpCreate_phone_number, 11)\r\n\r\n        signUpBtn.setOnClickListener {\r\n            var intent = Intent(this, LoginActivity::class.java)\r\n            startActivity(intent)\r\n        }\r\n\r\n        buttonLocation = findViewById(R.id.button_location) // 사용자 위치 조회 및 입력\r\n        buttonLocation.setOnClickListener {\r\n            requestLocationPermission()\r\n            showUserLocation()\r\n        }\r\n        val mapFragment = supportFragmentManager.findFragmentById(R.id.map) as SupportMapFragment\r\n        mapFragment.getMapAsync(this)\r\n\r\n        val buttonShowLocation = findViewById<Button>(R.id.button_location)\r\n        buttonShowLocation.setOnClickListener {\r\n            if (ContextCompat.checkSelfPermission(this,\r\n                    Manifest.permission.ACCESS_FINE_LOCATION)\r\n                == PackageManager.PERMISSION_GRANTED) {\r\n                // 위치 권한이 허용된 경우\r\n                showUserLocation()\r\n            } else {\r\n                // 위치 권한이 허용되지 않은 경우\r\n                ActivityCompat.requestPermissions(this,\r\n                    arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),\r\n                    REQUEST_LOCATION_PERMISSION)\r\n            }\r\n        }\r\n\r\n        // 아이디, 패스워드 초과 경고 메세지\r\n        fun textLengthChecker() {\r\n            signUptextIdLengthChecker.isCounterEnabled = true\r\n            signUptextPwLengthChecker.isCounterEnabled = true\r\n            lengthCheck.isCounterEnabled = true\r\n\r\n            signUptextIdLengthChecker.counterMaxLength = 15 // ID 최대 길이\r\n            signUptextPwLengthChecker.counterMaxLength = 20 // PW 최대 길이\r\n            lengthCheck.counterMaxLength = 10\r\n\r\n            signUptextIdLengthChecker.isErrorEnabled = true\r\n            signUptextPwLengthChecker.isErrorEnabled = true\r\n            lengthCheck.isErrorEnabled = true\r\n\r\n            signUPEdit_ID.addTextChangedListener(object : TextWatcher {\r\n                override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                }\r\n                override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                }\r\n                override fun afterTextChanged(p0: Editable?) {\r\n                    if (signUPEdit_ID.length() > 15) {\r\n                        signUptextIdLengthChecker.error = \"ID의 글자 수를 초과하였습니다.\"\r\n                    } else {\r\n                        signUptextIdLengthChecker.error = null\r\n                    }\r\n                    if (signUPEdit_ID.length() < 5) {\r\n                        signUptextIdLengthChecker.error = \"ID는 최소 5자 이상입니다.\"\r\n                    } else {\r\n                        signUptextIdLengthChecker.error = null\r\n                    }\r\n                }\r\n\r\n            })\r\n\r\n            signUPEdit_PW.addTextChangedListener(object : TextWatcher {\r\n                override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                }\r\n                override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                }\r\n                override fun afterTextChanged(p0: Editable?) {\r\n                    if (signUPEdit_PW.length() > 20) {\r\n                        signUptextPwLengthChecker.error = \"PW의 글자 수를 초과하였습니다.\"\r\n                    } else {\r\n                        signUptextIdLengthChecker.error = null\r\n                    }\r\n                    if (signUPEdit_PW.length() < 8) {\r\n                        signUptextPwLengthChecker.error = \"PW는 최소 8자 이상입니다.\"\r\n                    } else {\r\n                        signUptextIdLengthChecker.error = null\r\n                    }\r\n                }\r\n            })\r\n            signUpCreate_name.addTextChangedListener(object : TextWatcher {\r\n                override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                }\r\n                override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {\r\n                    if (signUpCreate_name.length() > 10) {\r\n                        lengthCheck.error = \"이름의 글자 수를 초과 하였습니다.\"\r\n                    } else {\r\n                        lengthCheck.error = null\r\n                    }\r\n                }\r\n                override fun afterTextChanged(p0: Editable?) {\r\n                }\r\n            })\r\n        }\r\n\r\n        notKorean(signUPEdit_ID) // id 한글 예외처리\r\n        notKorean(signUPEdit_PW) // pw 한글 예외처리\r\n        onlyKorean(signUpCreate_name) // 이름 입력시 한글만\r\n        checkwhite(signUpCreate_name) // 이름 입력시 공백 확인\r\n        textLengthChecker() // 문자길이 체크\r\n\r\n    }\r\n\r\n    // 한글예외처리 함수\r\n    fun notKorean(editText: EditText){\r\n        Log.d(TAG, \" - checkNotKorean\")\r\n        editText.addTextChangedListener(object : TextWatcher {\r\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {\r\n            }\r\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {\r\n            }\r\n            override fun afterTextChanged(s: Editable?) {\r\n                val text = s.toString()\r\n                if (text.matches(Regex(\"[ㄱ-ㅎ가-힣]+\"))) {\r\n                    editText.error = \"한글은 입력할 수 없습니다.\"\r\n                } else {\r\n                    editText.error = null\r\n                }\r\n            }\r\n        })\r\n    }\r\n    // 한글만 입력함수\r\n    fun onlyKorean(editText: EditText){\r\n        Log.d(TAG, \" - checkNotKorean\")\r\n        val pattern = Pattern.compile(\"[^ㄱ-ㅎ가-힣]*$\") // 한글을 제외한 문자열 패턴\r\n        editText.addTextChangedListener(object : TextWatcher {\r\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}\r\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\r\n            override fun afterTextChanged(s: Editable?) {\r\n                val text = s.toString()\r\n                val matcher = pattern.matcher(text)\r\n                if (matcher.matches()) {\r\n                    editText.error = \"한글을 제외한 문자열은 입력할 수 없습니다.\"\r\n                } else {\r\n                    editText.error = null\r\n                }\r\n            }\r\n        })\r\n    }\r\n    // 공백체크함수\r\n    fun checkwhite(editText: EditText){\r\n        editText.addTextChangedListener(object : TextWatcher {\r\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}\r\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\r\n            override fun afterTextChanged(s: Editable?) {\r\n                // EditText의 문자열 가져오기\r\n                val text = s.toString()\r\n                Log.d(TAG, \"${text} - checkWhiteSpace\")\r\n                // 결과 출력\r\n                if (text.contains(\" \")) {\r\n                    Log.d(TAG, \"${text} - 공백있음\")\r\n                    editText.error = \"공백이 포함되어 있습니다.\"\r\n                }\r\n            }\r\n        })\r\n\r\n    }\r\n    // 폰번호 입력시 11자제한, 숫자만 입력\r\n    fun setEditTextInput(editText: EditText, maxLength: Int) {\r\n        val inputFilter = arrayOf<InputFilter>(InputFilter { source, _, _, _, _, _ ->\r\n            if (source.toString().matches(Regex(\"[0-9]+\"))) {\r\n                null // 숫자일 경우, null 리턴\r\n            } else {\r\n                \"\" // 숫자가 아닐 경우, 빈 문자열(\"\") 리턴\r\n            }\r\n        })\r\n        editText.filters = inputFilter\r\n        editText.addTextChangedListener(object : TextWatcher {\r\n            override fun afterTextChanged(s: Editable?) {\r\n                val input = s.toString()\r\n                if (input.length > maxLength) {\r\n                    editText.error = \"입력할 수 있는 숫자는 ${maxLength}자리 이하입니다.\"\r\n                } else {\r\n                    editText.error = null\r\n                }\r\n                val text = s.toString()\r\n                Log.d(TAG, \"${text} - checkWhiteSpace\")\r\n                // 결과 출력\r\n                if (text.contains(\" \")) {\r\n                    Log.d(TAG, \"${text} - 공백있음\")\r\n                    editText.error = \"공백이 포함되어 있습니다.\"\r\n                }\r\n\r\n\r\n            }\r\n            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}\r\n            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}\r\n        })\r\n    }\r\n    // 사용자 위치 조회, 위치 입력\r\n    private fun showUserLocation() {\r\n        val editText = findViewById<EditText>(R.id.editText)\r\n        if (ContextCompat.checkSelfPermission(this,\r\n                Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {\r\n            mMap.isMyLocationEnabled = true\r\n\r\n            // 사용자 위치 가져오기\r\n            val fusedLocationProviderClient = LocationServices.getFusedLocationProviderClient(this)\r\n            fusedLocationProviderClient.lastLocation.addOnSuccessListener { location ->\r\n                if (location != null) {\r\n                    val geocoder = Geocoder(this, Locale.KOREAN)\r\n                    val addresses = geocoder.getFromLocation(location.latitude, location.longitude, 1)\r\n                    if (addresses != null) {\r\n                        if (addresses.isNotEmpty()) {\r\n                            val address = addresses[0]\r\n                            val addressStr = address.getAddressLine(0)\r\n                            editText.setText(addressStr)\r\n                        }\r\n                    }\r\n\r\n\r\n                    val latLng = LatLng(location.latitude, location.longitude)\r\n                    mMap.addMarker(MarkerOptions().position(latLng).title(\"User Location\"))\r\n                    mMap.moveCamera(CameraUpdateFactory.newLatLngZoom(latLng, 15f))\r\n                }\r\n            }\r\n        }\r\n    }\r\n    override fun onMapReady(googleMap: GoogleMap) {\r\n        mMap = googleMap\r\n        mMap.uiSettings.isZoomControlsEnabled = true\r\n    }\r\n    override fun onRequestPermissionsResult(\r\n        requestCode: Int,\r\n        permissions: Array<out String>,\r\n        grantResults: IntArray\r\n    ) {\r\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\r\n        if (requestCode == REQUEST_LOCATION_PERMISSION) {\r\n            if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\r\n                showUserLocation()\r\n            }\r\n        }\r\n    }\r\n    private fun requestLocationPermission() {\r\n        if (ContextCompat.checkSelfPermission(\r\n                this,\r\n                Manifest.permission.ACCESS_FINE_LOCATION\r\n            ) == PackageManager.PERMISSION_GRANTED\r\n        ) {\r\n            showUserLocation()\r\n        } else {\r\n            ActivityCompat.requestPermissions(\r\n                this,\r\n                arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),\r\n                REQUEST_LOCATION_PERMISSION\r\n            )\r\n        }\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/icontest2/SignUpActivity.kt b/app/src/main/java/com/example/icontest2/SignUpActivity.kt
--- a/app/src/main/java/com/example/icontest2/SignUpActivity.kt	(revision 225d742c0fbf6a64fb066cd6742ad190fb7a5e7d)
+++ b/app/src/main/java/com/example/icontest2/SignUpActivity.kt	(date 1679901168387)
@@ -1,5 +1,6 @@
 package com.example.icontest2
 
+import android.content.Intent
 import androidx.appcompat.app.AppCompatActivity
 import android.os.Bundle
 import android.text.Editable
@@ -10,10 +11,10 @@
 import com.example.icontest2.databinding.ActivitySignUpBinding
 import java.util.regex.Pattern
 import android.Manifest
-import android.content.Intent
 import android.content.pm.PackageManager
 import android.location.Geocoder
 import android.widget.Button
+import android.widget.Toast
 import androidx.core.app.ActivityCompat
 import androidx.core.content.ContextCompat
 import com.google.android.gms.location.LocationServices
@@ -28,18 +29,27 @@
 
 class SignUpActivity : AppCompatActivity(), OnMapReadyCallback {
     private lateinit var binding: ActivitySignUpBinding
+    private var TAG = "SignUpActivity"
     private lateinit var mMap: GoogleMap
     private lateinit var buttonLocation: Button
     private val REQUEST_LOCATION_PERMISSION = 1
-    private var TAG = "SignUpActivity"
+
+
 
     override fun onCreate(savedInstanceState: Bundle?){
         super.onCreate(savedInstanceState)
         binding = ActivitySignUpBinding.inflate(layoutInflater)
         setContentView(binding.root)
 
+        val returnIntent = Intent(this, LoginActivity::class.java)
+        val locationRegisterIntent = Intent(this, LocationRegisterActivity::class.java)
+
         // 아이디, 비밀번호, 비밀번호 확인, 이름, 휴대폰번호의 editText id
-        val signUpBtn = binding.signUpBtn
+        val signUpIdEdit = binding.signUpIdEdit // 아이디
+        val signUpPasswdEdit = binding.signUpPasswdEdit
+        val signUpCheckPasswdEdit = binding.signUpCheckPasswdEdit
+        val signUpNameEdit = binding.signUpNameEdit
+        val signUpPhoneEdit = binding.signUpPhoneEdit
         val signUptextIdLengthChecker = binding.mainTextInputLayoutID
         val signUptextPwLengthChecker = binding.mainTextInputLayoutPW
         val lengthCheck = binding.mainTextInputLayoutCreateName
@@ -49,17 +59,13 @@
         val signUpCreate_phone_number = binding.phoneNumberCreate // 폰번호 숫자만 11자제한
         setEditTextInput(signUpCreate_phone_number, 11)
 
-        signUpBtn.setOnClickListener {
-            var intent = Intent(this, LoginActivity::class.java)
-            startActivity(intent)
-        }
-
         buttonLocation = findViewById(R.id.button_location) // 사용자 위치 조회 및 입력
         buttonLocation.setOnClickListener {
             requestLocationPermission()
             showUserLocation()
         }
-        val mapFragment = supportFragmentManager.findFragmentById(R.id.map) as SupportMapFragment
+        val mapFragment =
+            supportFragmentManager.findFragmentById(R.id.map) as SupportMapFragment
         mapFragment.getMapAsync(this)
 
         val buttonShowLocation = findViewById<Button>(R.id.button_location)
@@ -77,6 +83,8 @@
             }
         }
 
+
+
         // 아이디, 패스워드 초과 경고 메세지
         fun textLengthChecker() {
             signUptextIdLengthChecker.isCounterEnabled = true
@@ -95,8 +103,6 @@
                 override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {
                 }
                 override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {
-                }
-                override fun afterTextChanged(p0: Editable?) {
                     if (signUPEdit_ID.length() > 15) {
                         signUptextIdLengthChecker.error = "ID의 글자 수를 초과하였습니다."
                     } else {
@@ -108,6 +114,8 @@
                         signUptextIdLengthChecker.error = null
                     }
                 }
+                override fun afterTextChanged(p0: Editable?) {
+                }
 
             })
 
@@ -115,8 +123,6 @@
                 override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {
                 }
                 override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {
-                }
-                override fun afterTextChanged(p0: Editable?) {
                     if (signUPEdit_PW.length() > 20) {
                         signUptextPwLengthChecker.error = "PW의 글자 수를 초과하였습니다."
                     } else {
@@ -128,6 +134,8 @@
                         signUptextIdLengthChecker.error = null
                     }
                 }
+                override fun afterTextChanged(p0: Editable?) {
+                }
             })
             signUpCreate_name.addTextChangedListener(object : TextWatcher {
                 override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {
@@ -144,14 +152,176 @@
             })
         }
 
+        val textWatcher = object : TextWatcher {
+            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
+            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}
+            // 사용자의 입력이 끝난 후 처리
+            override fun afterTextChanged(s: Editable?) {
+                Log.d(TAG, "${s}")
+                // 아이디
+                if (s == signUpIdEdit.editableText) {
+                    Log.d(TAG, "in - id - length")
+                    val minLength = 5
+                    val maxLength = 15
+                    checkWhiteSpace(s, signUpIdEdit) // 공백 문자 확인
+                    checkSpecialCharacters(s, signUpIdEdit) // 특수 문자 확인
+                    checkLength(s, signUpIdEdit, maxLength, minLength) // 문자열 길이 확인
+                }
+                // 비밀번호
+                if (s == signUpPasswdEdit.editableText) {
+                    Log.d(TAG, "in - pw - length")
+                    val minLength = 8
+                    val maxLength = 20
+                    checkWhiteSpace(s, signUpPasswdEdit) // 공백 문자 확인
+                    checkSpecialCharacters(s, signUpPasswdEdit) // 특수 문자 확인
+                    checkAlphaNumber(signUpPasswdEdit) // 영문 + 숫자 확인
+                    checkLength(s, signUpPasswdEdit, maxLength, minLength) // 문자열 길이 확인
+                }
+                // 비밀번호 체크
+                if (s == signUpCheckPasswdEdit.editableText) {
+                    Log.d(TAG, "in - pwcheck - length")
+                    if (signUpPasswdEdit.text.toString() != signUpCheckPasswdEdit.text.toString()) {
+                        signUpCheckPasswdEdit.error = "비밀번호가 일치하지 않습니다."
+                    } else {
+                        signUpCheckPasswdEdit.error = null
+                    }
+                }
+                // 이름
+                if (s == signUpNameEdit.editableText) {
+                    Log.d(TAG, "in - name - length")
+                    val minLength = 1
+                    val maxLength = 10
+                    checkWhiteSpace(s, signUpNameEdit) // 공백 문자 확인
+                    checkSpecialCharacters(s, signUpNameEdit) // 특수 문자 확인
+                    checkKorean(signUpNameEdit) // 한글 확인
+                    checkLength(s, signUpNameEdit, maxLength, minLength) // 문자열 길이 확인
+                }
+                // 휴대폰번호
+                if (s == signUpPhoneEdit.editableText) {
+                    Log.d(TAG, "in - phone - length")
+                    checkWhiteSpace(s, signUpPhoneEdit) // 공백 문자 확인
+                    checkSpecialCharacters(s, signUpPhoneEdit) // 특수 문자 확인
+                    checkPhoneNumber(signUpPhoneEdit) // 숫자 및 11자 확인
+                }
+            }
+        }
+
+        // 각 항목별 공백, 특수 문자 처리
+        signUpIdEdit.addTextChangedListener(textWatcher)
+        signUpPasswdEdit.addTextChangedListener(textWatcher)
+        signUpCheckPasswdEdit.addTextChangedListener(textWatcher)
+        signUpNameEdit.addTextChangedListener(textWatcher)
+        signUpPhoneEdit.addTextChangedListener(textWatcher)
         notKorean(signUPEdit_ID) // id 한글 예외처리
         notKorean(signUPEdit_PW) // pw 한글 예외처리
         onlyKorean(signUpCreate_name) // 이름 입력시 한글만
         checkwhite(signUpCreate_name) // 이름 입력시 공백 확인
         textLengthChecker() // 문자길이 체크
 
-    }
+        binding.signUpBtn.setOnClickListener {
+
+            returnIntent.putExtra("name", binding.signUpNameEdit.text.toString())
+            startActivity(returnIntent)
+            finish()
+        }
 
+        binding.signUpLocationBtn.setOnClickListener {
+            startActivity(locationRegisterIntent)
+        }
+
+    }
+    // 공백 문자 확인 함수
+    fun checkWhiteSpace(editable: Editable?, editText: EditText) {
+        // EditText의 문자열 가져오기
+        val text = editable.toString()
+        Log.d(TAG, "${text} - checkWhiteSpace")
+        // 결과 출력
+        if (text.contains(" ")) {
+            Log.d(TAG, "${text} - 공백있음")
+            editText.error = "공백이 포함되어 있습니다."
+        }
+    }
+
+    // 특수 문자 확인 함수
+    fun checkSpecialCharacters(editable: Editable?, editText: EditText) {
+        // EditText의 문자열 가져오기
+        val text = editable.toString()
+        Log.d(TAG, "${text} - checkSpecialCharacters")
+
+        // 검사할 특수 문자 지정
+        val specialCharacters = "!@#$%^&*()_-+=|\\{}[]:;\"'<>,.?/~`"
+
+        // 결과 출력
+        if (text.matches(".*[!@#\$%^&*(),.?\":{}|<>\\[\\]~-].*".toRegex())) {
+            editText.error = "특수문자는 입력할 수 없습니다."
+        }
+
+    }
+
+    // 문자 길이 확인 함수
+    fun checkLength(editable: Editable?, editText: EditText, maxLength: Int, minLength: Int) {
+        // EditText의 문자열 가져오기
+        val text = editable.toString()
+        Log.d(TAG, "${text} - checkLength")
+
+        val length = text.length
+
+        if (length < minLength) {
+            editText.error = "최소 ${minLength}자 이상 입력하세요"
+        } else if (length > maxLength) {
+            editText.error = "최대 ${maxLength}자까지 입력 가능합니다"
+        }
+
+    }
+
+    // 영문 + 숫자 확인 함수
+    fun checkAlphaNumber(editText: EditText) {
+        Log.d(TAG, " - checkAlphaNumber")
+
+        val alphaNumbericRegex = Regex("[a-zA-Z0-9]+")
+        val inputFilter = InputFilter { source, start, end, dest, dstart, dend ->
+            val input = dest.subSequence(0, dstart).toString() + source.subSequence(
+                start,
+                end
+            ) + dest.subSequence(dend, dest.length).toString()
+            return@InputFilter if (input.matches(alphaNumbericRegex)) null else ""
+        }
+        editText.filters = arrayOf(inputFilter)
+
+    }
+
+    // 한국어 확인 함수
+    fun checkKorean(editText: EditText) {
+        Log.d(TAG, " - checkKorean")
+
+        val inputFilter = InputFilter { source, _, _, _, _, _ ->
+            val regex = Regex("[ㄱ-ㅎ가-힣]+")
+            if (source.toString().matches(regex)) {
+                source
+            } else {
+                ""
+            }
+        }
+        editText.filters = arrayOf(inputFilter)
+    }
+
+    // 숫자 + 11글자 확인 함수
+    fun checkPhoneNumber(editText: EditText): Boolean {
+        Log.d(TAG, " - checkPhoneNumber")
+
+        val regex = Regex("[0-9]+")
+        val isNumeric = editText.text.toString().matches(regex)
+        val isElevenDigits = editText.text.toString().length == 11
+        // 숫자로만 이루어졌는지 확인
+        if (!isNumeric) {
+            editText.error = "숫자만 입력해주십시오."
+        }
+        // 11글자인지 확인
+        if (!isElevenDigits) {
+            editText.error = "11자리를 입력해주십시오."
+        }
+        return isNumeric && isElevenDigits
+    }
     // 한글예외처리 함수
     fun notKorean(editText: EditText){
         Log.d(TAG, " - checkNotKorean")
@@ -299,4 +469,20 @@
         }
     }
 
-}
\ No newline at end of file
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
